clc,clear

%微分方程，epsilon是参数
for i=1:5
    initialy(1,:) = zeros(1,4)+i;
end
initialy = zeros(4,1)+1;
[t,sol] = ode45(@rotation,[0,10],initialy);

%画图
c=1;
N = 10;%绘制点数
px0 = linspace(-1,1,N);
py0 = linspace(-1,1,N);
x0 = linspace(0,1,N);
[px,py]=meshgrid(px0,py0);

tau = zeros(N,N,4);
for i = 1:N
    for j =1:N
        for k = 1:N
            temptau = unknown(0,[x(1,i,1),0,px(j,1,1),py(1,1,k)]);
            tau(i,j,k,:) = temptau;
        end
    end
end
tx = c.*tau(:,:,:,1);
ty = c.*tau(:,:,:,2);
tpx = c.*tau(:,:,:,3);
tpy = c.*tau(:,:,:,4);
quiver3(x,px,py,tx,tpx,tpy);
xlabel('x')
ylabel('px')
zlabel('py')

function drot=rotation(t,cor)%generated by angular momentum, cor=[x,y,px,py]
drot=[-cor(2);cor(1);-cor(4);cor(3)];
end
function dunknown=unknown(t,cor)
x=cor(1);
y=cor(2);
px=cor(3);
py=cor(4);
depsilon_x = -((px^2*py* y^2 *(x^2 + y^2) - 2* px* py^2* x* y* (x^2 + y^2) + ...,
     2* px* x* y* sqrt(x^2 + y^2) + py^3* x^2* (x^2 + y^2) + ...,
     py* (y^2 - x^2)* sqrt(...,
      x^2 + y^2))/((px^2 + py^2) *(x^2 + y^2)* (py *x - px* y)^2 - ...,
     2 *sqrt(x^2 + y^2) *(py *x - px* y)^2 + x^2 + y^2));
depsilon_y = (2 *py* x* y* sqrt(x^2 + y^2) + px* (x^2 - y^2)* sqrt(x^2 + y^2) +..., 
   px* py^2* x^2 *(x^2 + y^2) - 2 *px^2* py* x* y* (x^2 + y^2) +..., 
   px^3* y^2* (x^2 + y^2))/(x^2 + y^2 -..., 
   2* (py* x - px* y)^2 *sqrt(...,
    x^2 + y^2) + (px^2 + py^2)* (py* x - px* y)^2* (x^2 + y^2));
depsilon_px = -((px^2 *y^3 + px *py* x *(x^2 - y^2) - y* sqrt(x^2 + y^2) + ...,
     py^2* (2* x^2* y + y^3))/(-2* (py* x - px* y)^2 *(x^2 + y^2) + (x^2 +..., 
       y^2)^(3/2) + (px^2 + py^2) *(py *x - px *y)^2 *(x^2 + y^2)^(3/2)));
depsilon_py = -((-py^2*x^3 + px *py* y *(x^2 - y^2) + x* sqrt(x^2 + y^2) - ...,
     px^2* (x^3 + 2* x* y^2))/(-2* (py* x - px *y)^2 *(x^2 + y^2) + (x^2 +..., 
       y^2)^(3/2) + (px^2 + py^2) *(py *x - px *y)^2 *(x^2 + y^2)^(3/2)));
dunknown=[depsilon_x;depsilon_y;depsilon_px;depsilon_py];
end
